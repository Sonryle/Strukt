#include <stdlib.h>
#include <glad/glad.h>
#include <GLFW/glfw3.h>

#include <client/logging.h>
#include <client/settings.h>
#include <client/renderer.h>
#include <client/window.h>

const char* fs =
        "#version 330 core\n"
        "out vec4 FragColor;\n"

        "void main()\n"
        "{\n"
        "FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
        "}\n";
float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};
GLuint VBO;
GLuint VAO;
GLuint vertex_shader;
GLuint fragment_shader;
GLuint shader_program;

int init_renderer()
{
        if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
        {
                log_err("failed to initialize GLAD");
                glfwTerminate();
                return -1;
        }

        glClearColor(settings.renderer->bgr, settings.renderer->bgg, settings.renderer->bgb, 1.0f);
        glViewport(0, 0, settings.window->initial_width, settings.window->initial_height);

        // Create Buffers
        // --------------

        /* Generate a buffer to store our vertices */
        glGenBuffers(1, &VBO);
        glGenVertexArrays(1, &VAO);

        /* Bind Vertex Array Buffer */
        glBindVertexArray(VAO);

        /* Bind buffer to GL_ARRAY_BUFFER buffer type */
        glBindBuffer(GL_ARRAY_BUFFER, VBO);

        /* Copy user-defined data into currently bound buffer of type GL_ARRAY_BUFFER */
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), &vertices, GL_STATIC_DRAW);

        // Create shaders
        // --------------

        /* Load vertex shader file & copy it into string */
        FILE* vs_file = fopen("shaders/source.vs", "r");
        char* vs_src = NULL;

        if (vs_file)
        {
                /* Move file pointer to end and record position into char_count */
                fseek(vs_file, 0, SEEK_END);
                int char_count = ftell(vs_file);
                log_debug("file is %ld characters (bytes) large", char_count);

                vs_src = (char*)malloc((char_count + 1) * sizeof(char));
                if (vs_src)
                {
                        /* Move file pointer to beginning and copy into vs_src */
                        fseek(vs_file, 0, SEEK_SET);
                        fread((void*)vs_src, sizeof(char), length, vs_file);
                        vs_src[length] = '\0';
                }
                fclose(vs_file);
        } else {
                log_err("could not find vertex shader file");
        }
        log_info("Loaded Shader:\n%s", vs_src);

        /* Create shaders */
        vertex_shader = glCreateShader(GL_VERTEX_SHADER);
        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
        
        /* Attach shader source code to shader objects */
        glShaderSource(vertex_shader, 1, (const GLchar**)&vs_src, NULL);
        glShaderSource(fragment_shader, 1, &fs, NULL);

        /* Compile shader & handle errors */
        glCompileShader(vertex_shader);
        glCompileShader(fragment_shader);

        int success;
        char info_log[512];
        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);
        if (!success)
        {
                glGetShaderInfoLog(vertex_shader, 512, NULL, info_log);
                log_err("could not compile vertex shader:\n%s", info_log);
                return -1;
        }
        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);
        if (!success)
        {
                glGetShaderInfoLog(fragment_shader, 512, NULL, info_log);
                log_err("could not compile fragment shader:\n%s", info_log);
                return -1;
        }

        // Shader Program
        // --------------

        shader_program = glCreateProgram();
        glAttachShader(shader_program, vertex_shader);
        glAttachShader(shader_program, fragment_shader);
        glLinkProgram(shader_program);
        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);
        if (!success)
        {
                glGetProgramInfoLog(shader_program, 512, NULL, info_log);
                log_err("could not link shader program:\n%s", info_log);
                return -1;
        }

        glUseProgram(shader_program);
        glDeleteShader(vertex_shader);
        free((void*)vs);
        glDeleteShader(fragment_shader);

        // Linking vertex attributes
        // -------------------------

        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        return 0;
}

int temporary_render()
{
        glClear(GL_COLOR_BUFFER_BIT);

        glUseProgram(shader_program);
        glBindVertexArray(VAO);
        glDrawArrays(GL_TRIANGLES, 0, 3);

        glfwSwapBuffers(window);

        return 0;
}

void terminate_renderer()
{

}
